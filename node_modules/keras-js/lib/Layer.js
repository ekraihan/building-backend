'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tensor = require('./Tensor');

var _Tensor2 = _interopRequireDefault(_Tensor);

var _ndarrayOps = require('ndarray-ops');

var _ndarrayOps2 = _interopRequireDefault(_ndarrayOps);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Layer class
 */
var Layer = function () {
  /**
   * Creates a layer
   * @param {Object} [attrs] - layer attributes
   */
  function Layer() {
    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Layer);

    this.layerClass = 'Layer';
    this.name = attrs.name;

    this.params = [];
    this.weights = {};

    // gpu and pipeline flags from Model
    this.gpu = attrs.gpu;
    this.pipeline = attrs.pipeline;

    // layer flags off by default
    this._useWeblas = false;
    this._pipelineEnabled = false;
  }

  /**
   * Method for setting layer weights
   * We store the weights as both Tensor instances,
   * as well as weblas pipeline tensors if possible (which are in GPU memory)
   * see https://github.com/waylonflinn/weblas/wiki/Pipeline
   *
   * @param {Tensor[]} weightsArr - array of weights which are instances of Tensor
   */


  _createClass(Layer, [{
    key: 'setWeights',
    value: function setWeights(weightsArr) {
      var _this = this;

      this.params.forEach(function (p, i) {
        _this.weights[p] = weightsArr[i];
      });
    }

    /**
     * Toggle GPU mode on/off
     * weblas must be available
     * @param {boolean} mode - on/off
     */

  }, {
    key: 'toggleGpu',
    value: function toggleGpu(mode) {
      var newMode = typeof mode === 'undefined' ? !this._useWeblas : mode;
      if (newMode && weblas) {
        this._useWeblas = true;
      } else {
        this._useWeblas = false;
      }
    }

    /**
     * Method for layer computational logic
     * @param {Tensor} x
     * @returns {Tensor} x
     */

  }, {
    key: 'call',
    value: function call(x) {
      return x;
    }

    /**
     * Pipeline transfer
     * Typically called at the end of a pipelined layer sequence.
      * @param {Tensor} x
     * @returns {Tensor} x
     */

  }, {
    key: 'transferFromPipeline',
    value: function transferFromPipeline(x) {
      if (!x.weblasTensor) {
        throw new Error('Variable passed in does not contain weblas tensor.');
      }
      if (!x._fromPipeline) {
        throw new Error('Variable passed in does not contain _fromPipeline.');
      }
      if (!x._actualShape) {
        throw new Error('Variable passed in does not contain _actualShape.');
      }

      // last axis is channel axis
      var channels = x.weblasTensor.shape[1];
      var nbPatches = x._actualShape.slice(0, -1).reduce(function (a, b) {
        return a * b;
      }, 1);

      var tiled = new _Tensor2.default([], x.weblasTensor.shape);
      tiled.tensor.data = x.weblasTensor.transfer();

      var output = new _Tensor2.default([], x._actualShape);
      var outputChannelRaveled = new _Tensor2.default([], [nbPatches]);
      var outputChannel = new _Tensor2.default([], x._actualShape.slice(0, -1));
      for (var n = 0; n < channels; n++) {
        var _output$tensor;

        _ndarrayOps2.default.assign(outputChannelRaveled.tensor, tiled.tensor.pick(null, n));
        outputChannel.replaceTensorData(outputChannelRaveled.tensor.data);
        var axisSlices = Array(x._actualShape.length - 1).fill(null);
        _ndarrayOps2.default.assign((_output$tensor = output.tensor).pick.apply(_output$tensor, _toConsumableArray(axisSlices).concat([n])), outputChannel.tensor);
      }

      output._fromPipeline = false;
      if (output._actualShape) {
        delete output._actualShape;
      }

      return output;
    }
  }]);

  return Layer;
}();

exports.default = Layer;