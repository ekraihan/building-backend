'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ndarray = require('ndarray');

var _ndarray2 = _interopRequireDefault(_ndarray);

var _ndarraySqueeze = require('ndarray-squeeze');

var _ndarraySqueeze2 = _interopRequireDefault(_ndarraySqueeze);

var _constants = require('./constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var checkShape = function checkShape(data, shape) {
  if (data.length && shape.length && data.length !== shape.reduce(function (a, b) {
    return a * b;
  }, 1)) {
    throw new Error('Specified shape incompatible with data.');
  }
};

/**
 * Tensor class
 */

var Tensor = function () {
  /**
   * Creates a tensor
   * @param {(TypedArray|Array)} data
   * @param {Array} shape
   * @param {Object} [options]
   */
  function Tensor(data, shape) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, Tensor);

    this._type = options.type || Float32Array;

    if (data && data.length && (data instanceof this._type || data instanceof Array)) {
      checkShape(data, shape);
      this.tensor = (0, _ndarray2.default)(data, shape);
      this.tensor = (0, _ndarray2.default)(new this._type(data), shape);
    } else if (!data.length && shape.length) {
      // if shape present but data not provided, initialize with 0s
      this.tensor = (0, _ndarray2.default)(new this._type(shape.reduce(function (a, b) {
        return a * b;
      }, 1)), shape);
    } else {
      this.tensor = (0, _ndarray2.default)(new this._type([]), []);
    }
  }

  /**
   * Replaces data in the underlying ndarray.
   */


  _createClass(Tensor, [{
    key: 'replaceTensorData',
    value: function replaceTensorData(data) {
      if (data && data.length && data instanceof this._type) {
        this.tensor.data = data;
      } else if (data && data.length && data instanceof Array) {
        this.tensor.data = new this._type(data);
      } else {
        throw new Error('[Tensor] invalid input for replaceTensorData method.');
      }
    }

    /**
     * Create weblas pipeline tensor in GPU memory
     * 1-D or 2-D only
     * see https://github.com/waylonflinn/weblas/wiki/Pipeline
     *
     * gl.MAX_TEXTURE_SIZE is a limiting factor.
     * Where this is exceeded, falls back to CPU.
     */

  }, {
    key: 'createWeblasTensor',
    value: function createWeblasTensor() {
      if (this.weblasTensor) {
        this.weblasTensor.delete();
      }

      if (this.tensor.shape.length === 1) {
        var len = this.tensor.shape[0];
        if (len > _constants.MAX_TEXTURE_SIZE) {
          this._gpuMaxSizeExceeded = true;
        } else {
          var shape = [1, len];
          this.weblasTensor = new weblas.pipeline.Tensor(shape, this.tensor.data);
        }
      } else if (this.tensor.shape.length === 2) {
        if (this.tensor.shape.some(function (s) {
          return s > _constants.MAX_TEXTURE_SIZE;
        })) {
          this._gpuMaxSizeExceeded = true;
        } else {
          var _shape = this.tensor.shape;
          this.weblasTensor = new weblas.pipeline.Tensor(_shape, this.tensor.data);
        }
      } else {
        throw new Error('[Tensor] can only create weblas Tensor for 1-D or 2-D only');
      }
    }

    /**
     * Delete weblas pipeline tensor
     */

  }, {
    key: 'deleteWeblasTensor',
    value: function deleteWeblasTensor() {
      if (this.weblasTensor) {
        this.weblasTensor.delete();
        delete this.weblasTensor;
      }
    }

    /**
     * Copies from another weblas pipeline tensor
     */

  }, {
    key: 'copyFromWeblasTensor',
    value: function copyFromWeblasTensor(weblasTensor) {
      var webgl = weblas.gpu.gl;
      var glCtx = webgl.context;
      var program = webgl.createProgram(require('./texture_copy.glsl'));
      this.weblasTensor = new weblas.pipeline.Tensor(weblasTensor.shape, null);

      webgl.selectProgram(program);
      glCtx.activeTexture(glCtx.TEXTURE0);
      glCtx.bindTexture(glCtx.TEXTURE_2D, weblasTensor.texture);
      var sampler = glCtx.getUniformLocation(program, 'source');
      glCtx.uniform1i(sampler, 0);

      // texture dimensions, with padding if necessary
      // bind to output texture
      // see https://github.com/waylonflinn/weblas/blob/master/lib/webgl.js#L478

      var _weblasTensor$shape = _slicedToArray(this.weblasTensor.shape, 2),
          h = _weblasTensor$shape[0],
          w = _weblasTensor$shape[1];

      var pad = webgl.getPad(w);
      webgl.bindOutputTexture(h, (w + pad) / 4, this.weblasTensor.texture);

      // run shader program to copy
      glCtx.drawElements(glCtx.TRIANGLES, 6, glCtx.UNSIGNED_SHORT, 0);

      // unbind source texture
      webgl.unbindInputTexture(glCtx.TEXTURE0);
    }
  }]);

  return Tensor;
}();

exports.default = Tensor;