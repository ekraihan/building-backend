'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getHistogram = getHistogram;
exports.getHistograms = getHistograms;

var _newArray = require('new-array');

var _newArray2 = _interopRequireDefault(_newArray);

var _isInteger = require('is-integer');

var _isInteger2 = _interopRequireDefault(_isInteger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Returns a histogram for the specified channel
 * @memberof Image
 * @instance
 * @param {object} [options]
 * @param {number} [options.maxSlots=256]
 * @param {number} [options.channel]
 * @param {boolean} [options.useAlpha=true]
 * @return {number[]}
 */
function getHistogram(options = {}) {
    var _options$maxSlots = options.maxSlots,
        maxSlots = _options$maxSlots === undefined ? 256 : _options$maxSlots,
        channel = options.channel,
        _options$useAlpha = options.useAlpha,
        useAlpha = _options$useAlpha === undefined ? true : _options$useAlpha;

    this.checkProcessable('getHistogram', {
        bitDepth: [1, 8, 16]
    });
    if (channel === undefined) {
        if (this.components > 1) {
            throw new RangeError('You need to define the channel for an image that contains more than one channel');
        }
        channel = 0;
    }
    return getChannelHistogram.call(this, channel, { useAlpha, maxSlots });
}

/**
 * Returns an array (number of channels) of array (number of slots) containing
 * the number of data of a specific intensity.
 * Intensity may be grouped by the maxSlots parameter.
 * @memberof Image
 * @instance
 * @param {object} [options]
 * @param {number} [options.maxSlots] - Number of slots in the resulting
 *      array. The intensity will be evently distributed between 0 and
 *      the maxValue allowed for this image (255 for usual images).
 *      If maxSlots = 8, all the intensities between 0 and 31 will be
 *      placed in the slot 0, 32 to 63 in slot 1, ...
 * @return {Array<Array<number>>}
 * @example
 *      image.getHistograms({
 *          maxSlots: 8,
 *          useAlpha: false
 *      });
 */
function getHistograms(options = {}) {
    var _options$maxSlots2 = options.maxSlots,
        maxSlots = _options$maxSlots2 === undefined ? 256 : _options$maxSlots2,
        _options$useAlpha2 = options.useAlpha,
        useAlpha = _options$useAlpha2 === undefined ? true : _options$useAlpha2;

    this.checkProcessable('getHistograms', {
        bitDepth: [8, 16]
    });
    var results = new Array(useAlpha ? this.components : this.channels);
    for (var i = 0; i < results.length; i++) {
        results[i] = getChannelHistogram.call(this, i, { useAlpha, maxSlots });
    }
    return results;
}

function getChannelHistogram(channel, options) {
    var useAlpha = options.useAlpha,
        maxSlots = options.maxSlots;

    //for a mask, return a number array containing count of black and white points (black = array[0], white = array[1])

    if (this.bitDepth === 1) {
        var blackWhiteCount = [0, 0];
        for (var i = 0; i < this.height; i++) {
            for (var j = 0; j < this.width; j++) {
                var value = this.getBitXY(i, j);
                if (value === 0) {
                    blackWhiteCount[0] += 1;
                } else if (value === 1) {
                    blackWhiteCount[1] += 1;
                }
            }
        }
        return blackWhiteCount;
    }

    var bitSlots = Math.log2(maxSlots);
    if (!(0, _isInteger2.default)(bitSlots)) {
        throw new RangeError('maxSlots must be a power of 2, for example: 64, 256, 1024');
    }
    // we will compare the bitSlots to the bitDepth of the image
    // based on this we will shift the values. This allows to generate a histogram
    // of 16 grey even if the images has 256 shade of grey

    var bitShift = 0;
    if (this.bitDepth > bitSlots) {
        bitShift = this.bitDepth - bitSlots;
    }

    var data = this.data;
    var result = (0, _newArray2.default)(Math.pow(2, Math.min(this.bitDepth, bitSlots)), 0);
    if (useAlpha && this.alpha) {
        var alphaChannelDiff = this.channels - channel - 1;

        for (var _i = channel; _i < data.length; _i += this.channels) {
            result[data[_i] >> bitShift] += data[_i + alphaChannelDiff] / this.maxValue;
        }
    } else {
        for (var _i2 = channel; _i2 < data.length; _i2 += this.channels) {
            result[data[_i2] >> bitShift]++;
        }
    }

    return result;
}