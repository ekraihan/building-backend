'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = getColorHistogram;

var _newArray = require('new-array');

var _newArray2 = _interopRequireDefault(_newArray);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @memberof Image
 * @instance
 * @param {object} [options]
 * @param {boolean} [options.useAlpha=true]
 * @param {number} [options.nbSlots=512]
 * @return {number[]}
 */
function getColorHistogram(options = {}) {
    var _options$useAlpha = options.useAlpha,
        useAlpha = _options$useAlpha === undefined ? true : _options$useAlpha,
        _options$nbSlots = options.nbSlots,
        nbSlots = _options$nbSlots === undefined ? 512 : _options$nbSlots;


    this.checkProcessable('getColorHistogram', {
        bitDepth: [8, 16],
        components: [3]
    });

    var nbSlotsCheck = Math.log(nbSlots) / Math.log(8);
    if (nbSlotsCheck !== Math.floor(nbSlotsCheck)) {
        throw new RangeError('nbSlots must be a power of 8. Usually 8, 64, 512 or 4096');
    }

    var bitShift = this.bitDepth - nbSlotsCheck;

    var data = this.data;
    var result = (0, _newArray2.default)(Math.pow(8, nbSlotsCheck), 0);
    var factor2 = Math.pow(2, nbSlotsCheck * 2);
    var factor1 = Math.pow(2, nbSlotsCheck);

    for (var i = 0; i < data.length; i += this.channels) {
        var slot = (data[i] >> bitShift) * factor2 + (data[i + 1] >> bitShift) * factor1 + (data[i + 2] >> bitShift);
        if (useAlpha && this.alpha) {
            result[slot] += data[i + this.channels - 1] / this.maxValue;
        } else {
            result[slot]++;
        }
    }

    return result;
}