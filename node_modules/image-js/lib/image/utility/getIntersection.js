"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = getIntersection;
/**
 * Find intersection of points between two different masks
 * @param {Image} - a mask (1 bit image)
 * @param {Image} - a mask (1 bit image)
 * @return {Object} - object containing number of white pixels for mask1, for mask 2 and for them both
 */
function getIntersection(mask2) {

    var mask1 = this;
    var closestParent = mask1.getClosestCommonParent(mask2);

    var startPos1 = mask1.getRelativePosition(closestParent, { defaultFurther: true });
    var allRelPos1 = getRelativePositionForAllPixels(mask1, startPos1);
    var startPos2 = mask2.getRelativePosition(closestParent, { defaultFurther: true });
    var allRelPos2 = getRelativePositionForAllPixels(mask2, startPos2);

    var commonSurface = getCommonSurface(allRelPos1, allRelPos2);
    //console.log('commonSurface: ' + commonSurface);
    var intersection = { whitePixelsMask1: [], whitePixelsMask2: [], commonWhitePixels: [] };

    for (var i = 0; i < commonSurface.length; i++) {
        var currentRelativePos = commonSurface[i];
        var realPos1 = [currentRelativePos[0] - startPos1[0], currentRelativePos[1] - startPos1[1]];
        var realPos2 = [currentRelativePos[0] - startPos2[0], currentRelativePos[1] - startPos2[1]];
        var valueBitMask1 = mask1.getBitXY(realPos1[0], realPos1[1]);
        var valueBitMask2 = mask2.getBitXY(realPos2[0], realPos2[1]);
        //console.log('valueBitMask1: ' + valueBitMask1 + ', valueBitMask2: ' + valueBitMask2);

        if (valueBitMask1 === 1 && valueBitMask2 === 1) {
            intersection.commonWhitePixels.push(currentRelativePos);
        }
    }

    for (var _i = 0; _i < allRelPos1.length; _i++) {
        var posX = void 0;
        var posY = void 0;
        if (_i !== 0) {
            posX = Math.floor(_i / (mask1.width - 1));
            posY = _i % (mask1.width - 1);
        }
        if (mask1.getBitXY(posX, posY) === 1) {
            //console.log("white px mask1 : " + allRelPos1[i]);
            intersection.whitePixelsMask1.push(allRelPos1[_i]);
        }
    }

    for (var _i2 = 0; _i2 < allRelPos2.length; _i2++) {
        var _posX = 0;
        var _posY = 0;
        if (_i2 !== 0) {
            _posX = Math.floor(_i2 / (mask2.width - 1));
            _posY = _i2 % (mask2.width - 1);
        }
        if (mask2.getBitXY(_posX, _posY) === 1) {
            //console.log("white px mask2 : " + allRelPos2[i]);
            intersection.whitePixelsMask2.push(allRelPos2[_i2]);
        }
    }

    return intersection;
}

/**
 * Get relative position array for all pixels in masks
 * @param {Image} - a mask (1 bit image)
 * @param {Array} - number array, start position of mask relative to parent
 * @returns {Array} - relative position of all pixels
 */
function getRelativePositionForAllPixels(mask, startPosition) {
    //console.log('startPosition: ' + startPosition);
    var relativePositions = [];
    for (var i = 0; i < mask.height; i++) {
        for (var j = 0; j < mask.width; j++) {
            var originalPos = [i, j];
            //console.log([originalPos[0] + startPosition[0], originalPos[1] + startPosition[1]]);
            relativePositions.push([originalPos[0] + startPosition[0], originalPos[1] + startPosition[1]]);
        }
    }
    //console.log('relativePositions: ' + relativePositions);
    return relativePositions;
}

/**
 * Finds common surface for two arrays containing the positions of the pixels relative to parent image
 * @param {Array} - number array containing positions of pixels relative to parent
 * @param {Array} - number array containing positions of pixels relative to parent
 * @returns {Array} - number array containing positions of common pixels for both arrays
 */
function getCommonSurface(positionArray1, positionArray2) {
    var i = 0;
    var j = 0;
    var commonSurface = [];
    while (i < positionArray1.length && j < positionArray2.length) {
        if (positionArray1[i][0] === positionArray2[j][0] && positionArray1[i][1] === positionArray2[j][1]) {
            commonSurface.push(positionArray1[i]);
            i++;
            j++;
        } else if (positionArray1[i][0] < positionArray2[j][0] || positionArray1[i][0] === positionArray2[j][0] && positionArray1[i][1] < positionArray2[j][1]) {
            i++;
        } else {
            j++;
        }
    }
    //console.log('commonSurface: ', commonSurface);
    return commonSurface;
}