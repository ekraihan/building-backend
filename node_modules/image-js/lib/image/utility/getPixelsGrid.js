'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = getPixelsGrid;
/**
 * @memberof Image
 * @instance
 * @param {object} [options]
 * @param {number[]} [options.sampling=[10, 10]]
 * @param {boolean} [options.painted=false]
 * @param {Image} [options.mask]
 * @return {object}
 */
function getPixelsGrid(options = {}) {
    var _options$sampling = options.sampling,
        sampling = _options$sampling === undefined ? [10, 10] : _options$sampling,
        _options$painted = options.painted,
        painted = _options$painted === undefined ? false : _options$painted,
        mask = options.mask;


    this.checkProcessable('getPixelsGrid', {
        bitDepth: [8, 16],
        channels: 1
    });

    if (!Array.isArray(sampling)) {
        sampling = [sampling, sampling];
    }

    var xSampling = sampling[0];
    var ySampling = sampling[1];
    var nbSamples = xSampling * ySampling;

    var xyS = new Array(nbSamples);
    var zS = new Array(nbSamples);

    var xStep = this.width / xSampling;
    var yStep = this.height / ySampling;
    var currentX = Math.floor(xStep / 2);

    var position = 0;
    for (var i = 0; i < xSampling; i++) {
        var currentY = Math.floor(yStep / 2);
        for (var j = 0; j < ySampling; j++) {
            var x = Math.round(currentX);
            var y = Math.round(currentY);
            if (!mask || mask.getBitXY(x, y)) {
                xyS[position] = [x, y];
                zS[position] = this.getPixelXY(x, y);
                position++;
            }
            currentY += yStep;
        }
        currentX += xStep;
    }

    // resize arrays if needed
    xyS.length = position;
    zS.length = position;

    var toReturn = { xyS, zS };

    if (painted) {
        toReturn.painted = this.rgba8().paintPoints(xyS);
    }

    return toReturn;
}