'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = setBorder;

var _newArray = require('new-array');

var _newArray2 = _interopRequireDefault(_newArray);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This method will change the border
 * @memberof Image
 * @instance
 * @param {object} [options]
 * @param {number} [options.size=0]
 * @param {string} [options.algorithm='copy']
 * @param {number[]} [options.color]
 * @return {this}
 */
function setBorder(options = {}) {
    var _options$size = options.size,
        size = _options$size === undefined ? 0 : _options$size,
        _options$algorithm = options.algorithm,
        algorithm = _options$algorithm === undefined ? 'copy' : _options$algorithm,
        color = options.color;


    this.checkProcessable('setBorder', {
        bitDepth: [8, 16, 32, 64]
    });

    if (algorithm === 'set') {
        if (color.length !== this.channels) {
            throw new Error('setBorder: the color array must have the same length as the number of channels. Here: ' + this.channels);
        }
        for (var i = 0; i < color.length; i++) {
            if (color[i] === 0) {
                color[i] = 0.001;
            }
        }
    } else {
        color = (0, _newArray2.default)(this.channels, null);
    }

    if (!Array.isArray(size)) {
        size = [size, size];
    }

    var leftRightSize = size[0];
    var topBottomSize = size[1];
    var channels = this.channels;

    for (var _i = leftRightSize; _i < this.width - leftRightSize; _i++) {
        for (var k = 0; k < channels; k++) {
            var value = color[k] || this.data[(_i + this.width * topBottomSize) * channels + k];
            for (var j = 0; j < topBottomSize; j++) {
                this.data[(j * this.width + _i) * channels + k] = value;
            }
            value = color[k] || this.data[(_i + this.width * (this.height - topBottomSize - 1)) * channels + k];
            for (var _j = this.height - topBottomSize; _j < this.height; _j++) {
                this.data[(_j * this.width + _i) * channels + k] = value;
            }
        }
    }

    for (var _j2 = 0; _j2 < this.height; _j2++) {
        for (var _k = 0; _k < channels; _k++) {
            var _value = color[_k] || this.data[(_j2 * this.width + leftRightSize) * channels + _k];
            for (var _i2 = 0; _i2 < leftRightSize; _i2++) {
                this.data[(_j2 * this.width + _i2) * channels + _k] = _value;
            }
            _value = color[_k] || this.data[(_j2 * this.width + this.width - leftRightSize - 1) * channels + _k];
            for (var _i3 = this.width - leftRightSize; _i3 < this.width; _i3++) {
                this.data[(_j2 * this.width + _i3) * channels + _k] = _value;
            }
        }
    }

    return this;
}