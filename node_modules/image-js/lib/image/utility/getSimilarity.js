'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = getSimilarity;

var _channel = require('./../../util/channel');

var _newArray = require('new-array');

var _newArray2 = _interopRequireDefault(_newArray);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Try to match the current pictures with another one. If normalize we normalize separately the 2 images.
 * @memberof Image
 * @instance
 * @param {Image} image - Other image
 * @param {object} [options]
 * @return {number[]|number}
 */
function getSimilarity(image, options = {}) {
    var _options$shift = options.shift,
        shift = _options$shift === undefined ? [0, 0] : _options$shift,
        average = options.average,
        channels = options.channels,
        defaultAlpha = options.defaultAlpha,
        normalize = options.normalize,
        _options$border = options.border,
        border = _options$border === undefined ? [0, 0] : _options$border;


    this.checkProcessable('getSimilarity', {
        bitDepth: [8, 16]
    });

    if (!Array.isArray(border)) {
        border = [border, border];
    }
    channels = (0, _channel.validateArrayOfChannels)(this, { channels: channels, defaultAlpha: defaultAlpha });

    if (this.bitDepth !== image.bitDepth) {
        throw new Error('Both images must have the same bitDepth');
    }
    if (this.channels !== image.channels) {
        throw new Error('Both images must have the same number of channels');
    }
    if (this.colorModel !== image.colorModel) {
        throw new Error('Both images must have the same colorModel');
    }

    if (typeof average === 'undefined') {
        average = true;
    }

    // we allow a shift
    // we need to find the minX, maxX, minY, maxY
    var minX = Math.max(border[0], -shift[0]);
    var maxX = Math.min(this.width - border[0], this.width - shift[0]);
    var minY = Math.max(border[1], -shift[1]);
    var maxY = Math.min(this.height - border[1], this.height - shift[1]);

    var results = (0, _newArray2.default)(channels.length, 0);
    for (var i = 0; i < channels.length; i++) {
        var c = channels[i];
        var sumThis = normalize ? this.sum[c] : Math.max(this.sum[c], image.sum[c]);
        var sumImage = normalize ? image.sum[c] : Math.max(this.sum[c], image.sum[c]);

        if (sumThis !== 0 && sumImage !== 0) {
            for (var x = minX; x < maxX; x++) {
                for (var y = minY; y < maxY; y++) {
                    var indexThis = x * this.multiplierX + y * this.multiplierY + c;
                    var indexImage = indexThis + shift[0] * this.multiplierX + shift[1] * this.multiplierY;
                    results[i] += Math.min(this.data[indexThis] / sumThis, image.data[indexImage] / sumImage);
                }
            }
        }
    }

    if (average) {
        return results.reduce((sum, x) => sum + x) / results.length;
    }
    return results;
}