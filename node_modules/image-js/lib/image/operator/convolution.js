'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = convolution;

var _Image = require('../Image');

var _Image2 = _interopRequireDefault(_Image);

var _channel = require('../../util/channel');

var _kernel = require('../../util/kernel');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var conv = require('ml-matrix-convolution');

/**
 * @memberof Image
 * @instance
 * @param {Array<Array<number>>} kernel
 * @param {object} [options] - options
 * @param {Array} [options.channels] - Array of channels to treat. Defaults to all channels
 * @param {number} [options.bitDepth=this.bitDepth] - A new bit depth can be specified. This allows to use 32 bits to avoid clamping of floating-point numbers.
 * @param {boolean} [options.normalize=false]
 * @param {number} [options.divisor=1]
 * @param {string} [options.border='copy']
 * @param {string} [options.algorithm='auto'] - Either 'auto', 'direct' or 'fft'. fft is much faster for large kernel.
 * @return {Image}
 */
function convolution(kernel, options = {}) {
    var channels = options.channels,
        bitDepth = options.bitDepth,
        _options$normalize = options.normalize,
        normalize = _options$normalize === undefined ? false : _options$normalize,
        _options$divisor = options.divisor,
        divisor = _options$divisor === undefined ? 1 : _options$divisor,
        _options$border = options.border,
        border = _options$border === undefined ? 'copy' : _options$border,
        _options$algorithm = options.algorithm,
        algorithm = _options$algorithm === undefined ? 'auto' : _options$algorithm;


    var newImage = _Image2.default.createFrom(this, { bitDepth });

    channels = (0, _channel.validateArrayOfChannels)(this, channels, true);
    //let kWidth, kHeight;
    //Very mysterious function. If the kernel is an array only one quadrant is copied to the output matrix,
    //but if the kernel is already a matrix, nothing is done.
    //On the other hand, it only consider odd, squared and symmetric kernels. A too restrictive
    //({kWidth, kHeight, kernel} = validateKernel(kernel));

    var _validateKernel = (0, _kernel.validateKernel)(kernel);

    kernel = _validateKernel.kernel;


    if (algorithm === 'auto') {
        if (kernel.length > 9 || kernel[0].length > 9) {
            algorithm = 'fft';
        } else {
            algorithm = 'direct';
        }
    }
    if (this.width > 4096 || this.height > 4096) {
        algorithm = 'direct';
    }

    var halfHeight = Math.floor(kernel.length / 2);
    var halfWidth = Math.floor(kernel[0].length / 2);
    var clamped = newImage.isClamped;

    var tmpData = new Array(this.height * this.width);
    var index = void 0,
        x = void 0,
        y = void 0,
        channel = void 0,
        c = void 0,
        tmpResult = void 0;
    for (channel = 0; channel < channels.length; channel++) {
        c = channels[channel];
        //Copy the channel in a single array
        for (y = 0; y < this.height; y++) {
            for (x = 0; x < this.width; x++) {
                index = y * this.width + x;
                tmpData[index] = this.data[index * this.channels + c];
            }
        }
        if (algorithm === 'direct') {
            tmpResult = conv.direct(tmpData, kernel, {
                rows: this.height,
                cols: this.width,
                normalize: normalize,
                divisor: divisor
            });
        } else {
            tmpResult = conv.fft(tmpData, kernel, {
                rows: this.height,
                cols: this.width,
                normalize: normalize,
                divisor: divisor
            });
        }

        //Copy the result to the output image
        for (y = 0; y < this.height; y++) {
            for (x = 0; x < this.width; x++) {
                index = y * this.width + x;
                if (clamped) {
                    newImage.data[index * this.channels + c] = Math.min(Math.max(tmpResult[index], 0), newImage.maxValue);
                } else {
                    newImage.data[index * this.channels + c] = tmpResult[index];
                }
            }
        }
    }
    // if the kernel was not applied on the alpha channel we just copy it
    // TODO: in general we should copy the channels that where not changed
    // TODO: probably we should just copy the image at the beginning ?
    if (this.alpha && !channels.includes(this.channels)) {
        for (x = this.components; x < this.data.length; x = x + this.channels) {
            newImage.data[x] = this.data[x];
        }
    }

    //I only can have 3 types of borders:
    //  1. Considering the image as periodic: periodic
    //  2. Extend the interior borders: copy
    //  3. fill with a color: set
    if (border !== 'periodic') {
        newImage.setBorder({ size: [halfWidth, halfHeight], algorithm: border });
    }

    return newImage;
}