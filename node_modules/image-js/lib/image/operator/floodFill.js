'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = floodFill;

var _fastList = require('fast-list');

var _fastList2 = _interopRequireDefault(_fastList);

var _Image = require('../Image');

var _Image2 = _interopRequireDefault(_Image);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function floodFill(options = {}) {
    var _options$x = options.x,
        x = _options$x === undefined ? 0 : _options$x,
        _options$y = options.y,
        y = _options$y === undefined ? 0 : _options$y,
        _options$inPlace = options.inPlace,
        inPlace = _options$inPlace === undefined ? true : _options$inPlace;


    var destination = inPlace ? this : _Image2.default.createFrom(this);

    this.checkProcessable('floodFill', { bitDepth: 1 });

    if (this.bitDepth === 1) {
        var bit = this.getBitXY(x, y);
        if (bit) return destination;
        var queue = new _fastList2.default();
        queue.push(new Node(x, y));
        while (queue.length > 0) {
            var node = queue.shift();
            destination.setBitXY(node.x, node.y);
            for (var i = node.x + 1; i < this.width; i++) {
                if (!destination.getBitXY(i, node.y) && !this.getBitXY(i, node.y)) {
                    destination.setBitXY(i, node.y);
                    if (node.y + 1 < this.height && !this.getBitXY(i, node.y + 1)) {
                        queue.push(new Node(i, node.y + 1));
                    }
                    if (node.y - 1 >= 0 && !this.getBitXY(i, node.y - 1)) {
                        queue.push(new Node(i, node.y - 1));
                    }
                } else {
                    break;
                }
            }
            for (var _i = node.x - 1; _i >= 0; _i++) {
                if (!destination.getBitXY(_i, node.y) && !this.getBitXY(_i, node.y)) {
                    destination.setBitXY(_i, node.y);
                    if (node.y + 1 < this.height && !this.getBitXY(_i, node.y + 1)) {
                        queue.push(new Node(_i, node.y + 1));
                    }
                    if (node.y - 1 >= 0 && !this.getBitXY(_i, node.y - 1)) {
                        queue.push(new Node(_i, node.y - 1));
                    }
                } else {
                    break;
                }
            }
        }
    }

    return destination;
}

function Node(x, y) {
    this.x = x;
    this.y = y;
}