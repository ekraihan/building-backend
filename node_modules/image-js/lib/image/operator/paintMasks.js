'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = paintMasks;

var _model = require('../model/model');

var _color = require('../../util/color');

/**
 * Paint a mask or masks on the current image.
 * @memberof Image
 * @instance
 * @param {(Image|Array<Image>)}     masks - Image containing a binary mask
 * @param {object}              [options]
 * @param {Array<number>|string}     [options.color='red'] - Array of 3 elements (R, G, B) or a valid css color.
 * @param {Array<Array<number>>|Array<string>} [options.colors] - Array of Array of 3 elements (R, G, B) for each color of each mask
 * @param {number}              [options.alpha=255] - Value from 0 to 255 to specify the alpha.
 * @param {boolean}             [options.randomColors=false] - To paint each mask with a random color
 * @param {boolean}             [options.distinctColors=false] - To paint each mask with a different color
 * @param {Array<string>}       [options.labels] - Array of labels to display. Should the the same size as masks.
 * @param {Array<Array<number>>} [options.labelsPosition] - Array of points [x,y] where the labels should be displayed.
 *                                      By default it is the 0,0 position of the correesponding mask.
 * @param {string}              [options.labelColor='blue'] - Define the color to paint the labels
 * @param {string}              [options.labelFont='12px Helvetica'] - Paint the labels in a different CSS style
 * @return {this} The original painted image
 */
function paintMasks(masks, options = {}) {
    var _options$color = options.color,
        color = _options$color === undefined ? 'red' : _options$color,
        colors = options.colors,
        _options$alpha = options.alpha,
        alpha = _options$alpha === undefined ? 255 : _options$alpha,
        _options$randomColors = options.randomColors,
        randomColors = _options$randomColors === undefined ? false : _options$randomColors,
        _options$distinctColo = options.distinctColors,
        distinctColors = _options$distinctColo === undefined ? false : _options$distinctColo,
        _options$labels = options.labels,
        labels = _options$labels === undefined ? [] : _options$labels,
        _options$labelsPositi = options.labelsPosition,
        labelsPosition = _options$labelsPositi === undefined ? [] : _options$labelsPositi,
        _options$labelColor = options.labelColor,
        labelColor = _options$labelColor === undefined ? 'blue' : _options$labelColor,
        _options$labelFont = options.labelFont,
        labelFont = _options$labelFont === undefined ? '12px Helvetica' : _options$labelFont;


    this.checkProcessable('paintMasks', {
        channels: [3, 4],
        bitDepth: [8, 16],
        colorModel: _model.RGB
    });

    if (color && !Array.isArray(color)) {
        color = (0, _color.css2array)(color);
    }

    if (colors) {
        colors = colors.map(function (color) {
            if (!Array.isArray(color)) {
                return (0, _color.css2array)(color);
            }
            return color;
        });
    }

    if (!Array.isArray(masks)) {
        masks = [masks];
    }

    if (distinctColors) {
        colors = (0, _color.getDistinctColors)(masks.length);
    }

    for (var i = 0; i < masks.length; i++) {
        var mask = masks[i];
        // we need to find the parent image to calculate the relative position

        if (colors) {
            color = colors[i % colors.length];
        } else if (randomColors) {
            color = (0, _color.getRandomColor)();
        }

        for (var x = 0; x < mask.width; x++) {
            for (var y = 0; y < mask.height; y++) {
                if (mask.getBitXY(x, y)) {
                    for (var component = 0; component < Math.min(this.components, color.length); component++) {
                        if (alpha === 255) {
                            this.setValueXY(x + mask.position[0], y + mask.position[1], component, color[component]);
                        } else {
                            var value = this.getValueXY(x + mask.position[0], y + mask.position[1], component);
                            value = Math.round((value * (255 - alpha) + color[component] * alpha) / 255);
                            this.setValueXY(x + mask.position[0], y + mask.position[1], component, value);
                        }
                    }
                }
            }
        }
    }

    if (Array.isArray(labels) && labels.length > 0) {
        var canvas = this.getCanvas({ originalData: true });
        var ctx = canvas.getContext('2d');
        ctx.fillStyle = labelColor;
        ctx.font = labelFont;
        for (var _i = 0; _i < Math.min(masks.length, labels.length); _i++) {
            var position = labelsPosition[_i] ? labelsPosition[_i] : masks[_i].position;
            ctx.fillText(labels[_i], position[0], position[1]);
        }
        this.setData(ctx.getImageData(0, 0, this.width, this.height).data);
    }

    return this;
}