'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = gaussianFilter;

var _convolution = require('../operator/convolution');

var _convolution2 = _interopRequireDefault(_convolution);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Apply a gaussian filter to the image
 * @memberof Image
 * @instance
 * @param {object} options
 * @param {number} [options.radius=1] : number of pixels around the current pixel
 * @param {number} [options.sigma]
 * @param {number[]|string[]} [options.channels] : to which channel to apply the filter. By default all but alpha.
 * @param {string} [options.border='copy']
 * @param {boolean} [options.algorithm='auto'] : Algorithm for convolution {@link Image#convolution}
 * @return {Image}
 */
function gaussianFilter(options = {}) {
    var _options$radius = options.radius,
        radius = _options$radius === undefined ? 1 : _options$radius,
        sigma = options.sigma,
        channels = options.channels,
        _options$border = options.border,
        border = _options$border === undefined ? 'copy' : _options$border,
        _options$algorithm = options.algorithm,
        algorithm = _options$algorithm === undefined ? 'auto' : _options$algorithm;

    this.checkProcessable('gaussian', {
        bitDepth: [8, 16]
    });

    var kernel = void 0;
    if (sigma) {
        kernel = getSigmaKernel(sigma);
    } else {
        // sigma approximation using radius
        sigma = 0.3 * (radius - 1) + 0.8;
        kernel = getKernel(radius, sigma);
    }

    return _convolution2.default.call(this, kernel, {
        border: border,
        channels: channels,
        algorithm: algorithm
    });
}

function getKernel(radius, sigma) {
    if (radius < 1) {
        throw new RangeError('Radius should be grater than 0');
    }
    var n = 2 * radius + 1;

    var kernel = new Array(n * n);

    //gaussian kernel is calculated
    var sigma2 = 2 * (sigma * sigma); //2*sigma^2
    var PI2sigma2 = Math.PI * sigma2; //2*PI*sigma^2

    for (var i = 0; i <= radius; i++) {
        for (var j = i; j <= radius; j++) {
            var value = Math.exp(-(i * i + j * j) / sigma2) / PI2sigma2;
            kernel[(i + radius) * n + (j + radius)] = value;
            kernel[(i + radius) * n + (-j + radius)] = value;
            kernel[(-i + radius) * n + (j + radius)] = value;
            kernel[(-i + radius) * n + (-j + radius)] = value;
            kernel[(j + radius) * n + (i + radius)] = value;
            kernel[(j + radius) * n + (-i + radius)] = value;
            kernel[(-j + radius) * n + (i + radius)] = value;
            kernel[(-j + radius) * n + (-i + radius)] = value;
        }
    }
    return kernel;
}

function getSigmaKernel(sigma) {
    if (sigma <= 0) {
        throw new RangeError('Sigma should be grater than 0');
    }
    var sigma2 = 2 * (sigma * sigma); //2*sigma^2
    var PI2sigma2 = Math.PI * sigma2; //2*PI*sigma^2
    var value = 1 / PI2sigma2;
    var sum = value;
    var neighbors = 0;

    while (sum < 0.99) {
        neighbors++;
        value = Math.exp(-(neighbors * neighbors) / sigma2) / PI2sigma2;
        sum += 4 * value;
        for (var i = 1; i < neighbors; i++) {
            value = Math.exp(-(i * i + neighbors * neighbors) / sigma2) / PI2sigma2;
            sum += 8 * value;
        }
        value = 4 * Math.exp(-(2 * neighbors * neighbors) / sigma2) / PI2sigma2;
        sum += value;
    }

    // What does this case mean ?
    if (sum > 1) {
        throw new Error('unexpected sum over 1');
    }

    return getKernel(neighbors, sigma);
}