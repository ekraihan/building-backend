'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = level;

var _newArray = require('new-array');

var _newArray2 = _interopRequireDefault(_newArray);

var _channel = require('../../util/channel');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Level the image for by default have the minimal and maximal values.
 * @memberof Image
 * @instance
 * @param {object} options
 * @param {(undefined|number|string|[number]|[string])} [options.channels=undefined] Specify which channels should be processed
 *      * undefined : we take all the channels but alpha
 *      * number : this specific channel
 *      * string : converted to a channel based on rgb, cmyk, hsl or hsv (one letter code)
 *      * [number] : array of channels as numbers
 *      * [string] : array of channels as one letter string
 * @param {number} [options.min=this.min] minimal value after levelling
 * @param {number} [options.max=this.max] maximal value after levelling
 * @return {this}
 */
function level(options = {}) {
    var _options$algorithm = options.algorithm,
        algorithm = _options$algorithm === undefined ? 'range' : _options$algorithm,
        channels = options.channels,
        _options$min = options.min,
        min = _options$min === undefined ? this.min : _options$min,
        _options$max = options.max,
        max = _options$max === undefined ? this.max : _options$max;


    this.checkProcessable('level', {
        bitDepth: [8, 16]
    });

    channels = (0, _channel.validateArrayOfChannels)(this, { channels: channels });

    switch (algorithm) {
        case 'range':
            if (min < 0) {
                min = 0;
            }
            if (max > this.maxValue) {
                max = this.maxValue;
            }

            if (!Array.isArray(min)) {
                min = (0, _newArray2.default)(channels.length, min);
            }
            if (!Array.isArray(max)) {
                max = (0, _newArray2.default)(channels.length, max);
            }

            processImage(this, min, max, channels);
            break;

        default:
            throw new Error('level: algorithm not implement: ' + algorithm);
    }

    return this;
}

function processImage(image, min, max, channels) {
    var delta = 1e-5; // sorry no better value that this "best guess"
    var factor = new Array(image.channels);

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = channels[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var c = _step.value;

            if (min[c] === 0 && max[c] === image.maxValue) {
                factor[c] = 0;
            } else if (max[c] === min[c]) {
                factor[c] = 0;
            } else {
                factor[c] = (image.maxValue + 1 - delta) / (max[c] - min[c]);
            }
            min[c] += (0.5 - delta / 2) / factor[c];
        }

        /*
         Note on border effect
         For 8 bits images we should calculate for the space between -0.5 and 255.5
         so that after ronding the first and last points still have the same population
         But doing this we need to deal with Math.round that gives 256 if the value is 255.5
         */
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    for (var j = 0; j < channels.length; j++) {
        var _c = channels[j];
        if (factor[_c] !== 0) {
            for (var i = 0; i < image.data.length; i += image.channels) {
                image.data[i + _c] = Math.min(Math.max(0, (image.data[i + _c] - min[_c]) * factor[_c] + 0.5 | 0), image.maxValue);
            }
        }
    }
}