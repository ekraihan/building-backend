'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = medianFilter;

var _channel = require('../../util/channel');

var _numSort = require('num-sort');

var _Image = require('../Image');

var _Image2 = _interopRequireDefault(_Image);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
* Each pixel of the image becomes the median of the neightbour
 * pixels.
 * @memberof Image
* @instance
* @param {object} options
* @param {(undefined|number|string|[number]|[string])} [options.channels=undefined] Specify which channels should be processed
*      * undefined : we take all the channels but alpha
*      * number : this specific channel
*      * string : converted to a channel based on rgb, cmyk, hsl or hsv (one letter code)
*      * [number] : array of channels as numbers
*      * [string] : array of channels as one letter string
* @param {number} [options.radius=1] distance of the square to take the mean of.
* @param {string} [options.border='copy'] algorithm that will be applied after to deal with borders
* @return {Image}
*/
function medianFilter(options = {}) {
    var _options$radius = options.radius,
        radius = _options$radius === undefined ? 1 : _options$radius,
        channels = options.channels,
        _options$border = options.border,
        border = _options$border === undefined ? 'copy' : _options$border;


    this.checkProcessable('median', {
        bitDepth: [8, 16]
    });

    if (radius < 1) {
        throw new Error('Kernel radius should be greater than 0');
    }

    channels = (0, _channel.validateArrayOfChannels)(this, channels, true);

    var kWidth = radius;
    var kHeight = radius;
    var newImage = _Image2.default.createFrom(this);

    var size = (kWidth * 2 + 1) * (kHeight * 2 + 1);
    var middle = Math.floor(size / 2);
    var kernel = new Array(size);

    for (var channel = 0; channel < channels.length; channel++) {
        var c = channels[channel];
        for (var y = kHeight; y < this.height - kHeight; y++) {
            for (var x = kWidth; x < this.width - kWidth; x++) {
                var n = 0;
                for (var j = -kHeight; j <= kHeight; j++) {
                    for (var i = -kWidth; i <= kWidth; i++) {
                        var _index = ((y + j) * this.width + x + i) * this.channels + c;
                        kernel[n++] = this.data[_index];
                    }
                }
                var index = (y * this.width + x) * this.channels + c;
                var newValue = kernel.sort(_numSort.asc)[middle];

                newImage.data[index] = newValue;
            }
        }
    }
    if (this.alpha && !channels.includes(this.channels)) {
        for (var _i = this.components; _i < this.data.length; _i = _i + this.channels) {
            newImage.data[_i] = this.data[_i];
        }
    }

    newImage.setBorder({ size: [kWidth, kHeight], algorithm: border });

    return newImage;
} //End median function