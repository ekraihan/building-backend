'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Image = require('../Image');

var _Image2 = _interopRequireDefault(_Image);

var _kindNames = require('../kindNames');

var KindNames = _interopRequireWildcard(_kindNames);

var _Shape = require('../../util/Shape');

var _Shape2 = _interopRequireDefault(_Shape);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Class to manage Region Of Interests
 * @class Roi
 */
class Roi {

    constructor(map, id) {
        this.map = map;
        this.id = id;
        this.minX = Number.POSITIVE_INFINITY;
        this.maxX = Number.NEGATIVE_INFINITY;
        this.minY = Number.POSITIVE_INFINITY;
        this.maxY = Number.NEGATIVE_INFINITY;
        this.meanX = 0;
        this.meanY = 0;
        this.surface = 0;
        this.computed = {};
    }

    /**
     * Returns a binary image (mask) for the corresponding ROI
     * @param {object} [options]
     * @param {number} [options.scale=1] - Scaling factor to apply to the mask
     * @param {string} [options.kind='normal'] - 'contour', 'box', 'filled', 'center' or 'normal'
     * @return {Image} - Returns a mask (1 bit Image)
     */
    getMask(options = {}) {
        var _options$scale = options.scale,
            scale = _options$scale === undefined ? 1 : _options$scale,
            _options$kind = options.kind,
            kind = _options$kind === undefined ? '' : _options$kind;

        var mask = void 0;
        switch (kind) {
            case 'contour':
                mask = this.contourMask;
                break;
            case 'box':
                mask = this.boxMask;
                break;
            case 'filled':
                mask = this.filledMask;
                break;
            case 'center':
                mask = this.centerMask;
                break;
            default:
                mask = this.mask;
        }

        if (scale < 1) {
            // by reassigning the mask we loose the parent and therefore the position
            // we will have to force it back
            mask = mask.scale({ factor: scale });
            mask.parent = this.mask.parent;
            mask.position[0] += this.minX;
            mask.position[1] += this.minY;
        }

        return mask;
    }

    get mean() {
        throw new Error('Roi mean not implemented yet');
        // return [this.meanX,this.meanY];
    }

    get center() {
        if (this.computed.center) {
            return this.computed.center;
        }
        return this.computed.center = [this.width / 2 >> 0, this.height / 2 >> 0];
    }

    get ratio() {
        return this.width / this.height;
    }

    get width() {
        return this.maxX - this.minX + 1;
    }

    get height() {
        return this.maxY - this.minY + 1;
    }

    _computExternalIDs() {
        // take all the borders and remove the internal one ...
        var borders = this.borderIDs;
        var lengths = this.borderLengths;

        this.computed.externalIDs = [];
        this.computed.externalLengths = [];

        var internals = this.internalIDs;

        for (var i = 0; i < borders.length; i++) {
            if (!internals.includes(borders[i])) {
                this.computed.externalIDs.push(borders[i]);
                this.computed.externalLengths.push(lengths[i]);
            }
        }
    }

    get externalIDs() {
        if (this.computed.externalIDs) {
            return this.computed.externalIDs;
        }
        this._computExternalIDs();
        return this.computed.externalIDs;
    }

    get externalLengths() {
        if (this.computed.externalLengths) {
            return this.computed.externalLengths;
        }
        this._computExternalIDs();
        return this.computed.externalLengths;
    }

    _computeBorderIDs() {
        var borders = getBorders(this);
        this.computed.borderIDs = borders.ids;
        this.computed.borderLengths = borders.lengths;
    }

    /**
     Retrieve all the IDs (array of number) of the regions that are in contact with this
     specific region. It may be external or internal
     */
    get borderIDs() {
        if (this.computed.borderIDs) {
            return this.computed.borderIDs;
        }
        this._computeBorderIDs();
        return this.computed.borderIDs;
    }

    /**
     Retrieve all the length (array of number) of the contacts with this
     specific region. It may be external or internal
     */
    get borderLengths() {
        if (this.computed.borderLengths) {
            return this.computed.borderLengths;
        }
        this._computeBorderIDs();
        return this.computed.borderLengths;
    }

    /**
     Retrieve all the IDs or the Roi touching the box surrouding the region
      It should really be an array to solve complex cases related to border effect
      Like the image
     <pre>
     0000
     1111
     0000
     1111
     </pre>
      The first row of 1 will be surrouned by 2 differents zones
      Or even worse
     <pre>
     010
     111
     010
     </pre>
     The cross will be surrouned by 4 differents zones
      However in most of the cases it will be an array of one element
     */
    get boxIDs() {
        if (this.computed.boxIDs) {
            return this.computed.boxIDs;
        }
        return this.computed.boxIDs = getBoxIDs(this);
    }

    get internalIDs() {
        if (this.computed.internalIDs) {
            return this.computed.internalIDs;
        }
        return this.computed.internalIDs = getInternalIDs(this);
    }

    /**
     Number of pixels of the Roi that touch the rectangle
     This is useful for the calculation of the border
     because we will ignore those special pixels of the rectangle
     border that don't have neighbours all around them.
     */
    get box() {
        // points of the Roi that touch the rectangular shape
        if (this.computed.box) {
            return this.computed.box;
        }
        return this.computed.box = getBox(this);
    }

    /**
     Calculates the number of pixels that are in the external border of the Roi
     Contour are all the pixels that touch an external "zone".
     All the pixels that touch the box are part of the border and
     are calculated in the getBoxPixels procedure
     */
    get external() {
        if (this.computed.external) {
            return this.computed.external;
        }
        return this.computed.external = getExternal(this);
    }

    /**
     Calculates the number of pixels that are involved in border
     Border are all the pixels that touch another "zone". It could be external
     or internal. If there is a hole in the zone it will be counted as a border.
     All the pixels that touch the box are part of the border and
     are calculated in the getBoxPixels procedure
     */
    get border() {
        if (this.computed.border) {
            return this.computed.border;
        }
        return this.computed.border = getBorder(this);
    }

    /**
        Returns a binary image (mask) containing only the border of the mask
     */
    get contourMask() {
        if (this.computed.contourMask) {
            return this.computed.contourMask;
        }

        var img = new _Image2.default(this.width, this.height, {
            kind: KindNames.BINARY,
            position: [this.minX, this.minY],
            parent: this.map.parent
        });

        for (var x = 0; x < this.width; x++) {
            for (var y = 0; y < this.height; y++) {
                if (this.map.data[x + this.minX + (y + this.minY) * this.map.width] === this.id) {
                    // it also has to be on a border ...
                    if (x > 0 && x < this.width - 1 && y > 0 && y < this.height - 1) {
                        if (this.map.data[x - 1 + this.minX + (y + this.minY) * this.map.width] !== this.id || this.map.data[x + 1 + this.minX + (y + this.minY) * this.map.width] !== this.id || this.map.data[x + this.minX + (y - 1 + this.minY) * this.map.width] !== this.id || this.map.data[x + this.minX + (y + 1 + this.minY) * this.map.width] !== this.id) {
                            img.setBitXY(x, y);
                        }
                    } else {
                        img.setBitXY(x, y);
                    }
                }
            }
        }
        return this.computed.contour = img;
    }

    get boxMask() {
        if (this.computed.boxMask) {
            return this.computed.boxMask;
        }

        var img = new _Image2.default(this.width, this.height, {
            kind: KindNames.BINARY,
            position: [this.minX, this.minY],
            parent: this.map.parent
        });

        for (var x = 0; x < this.width; x++) {
            img.setBitXY(x, 0);
            img.setBitXY(x, this.height - 1);
        }
        for (var y = 0; y < this.height; y++) {
            img.setBitXY(0, y);
            img.setBitXY(this.width - 1, y);
        }
        return this.computed.boxMask = img;
    }

    /**
     Returns a binary image containing the mask
     */
    get mask() {
        if (this.computed.mask) {
            return this.computed.mask;
        }

        var img = new _Image2.default(this.width, this.height, {
            kind: KindNames.BINARY,
            position: [this.minX, this.minY],
            parent: this.map.parent
        });

        for (var x = 0; x < this.width; x++) {
            for (var y = 0; y < this.height; y++) {
                if (this.map.data[x + this.minX + (y + this.minY) * this.map.width] === this.id) {
                    img.setBitXY(x, y);
                }
            }
        }
        return this.computed.mask = img;
    }

    get filledMask() {
        if (this.computed.filledMask) {
            return this.computed.filledMask;
        }

        var img = new _Image2.default(this.width, this.height, {
            kind: KindNames.BINARY,
            position: [this.minX, this.minY],
            parent: this.map.parent
        });

        for (var x = 0; x < this.width; x++) {
            for (var y = 0; y < this.height; y++) {
                var target = x + this.minX + (y + this.minY) * this.map.width;
                if (this.internalIDs.includes(this.map.data[target])) {
                    img.setBitXY(x, y);
                } // by default a pixel is to 0 so no problems, it will be transparent
            }
        }
        return this.computed.filledMask = img;
    }

    get centerMask() {
        if (this.computed.centerMask) {
            return this.computed.centerMask;
        }

        var img = new _Shape2.default({ kind: 'smallCross' }).getMask();

        img.parent = this.map.parent;
        img.position = [this.minX + this.center[0] - 1, this.minY + this.center[1] - 1];

        return this.computed.centerMask = img;
    }

    get points() {
        if (this.computed.points) {
            return this.computed.points;
        }
        var points = [];
        for (var y = 0; y < this.height; y++) {
            for (var x = 0; x < this.width; x++) {
                var target = (y + this.minY) * this.map.width + x + this.minX;
                if (this.map.data[target] === this.id) {
                    points.push([x, y]);
                }
            }
        }
        return this.computed.points = points;
    }

    get maxLengthPoints() {
        if (this.computed.maxLengthPoints) {
            return this.computed.maxLengthPoints;
        }
        var maxLength = 0;
        var maxLengthPoints = void 0;
        var points = this.points;

        for (var i = 0; i < points.length; i++) {
            for (var j = i + 1; j < points.length; j++) {
                var currentML = Math.pow(points[i][0] - points[j][0], 2) + Math.pow(points[i][1] - points[j][1], 2);
                if (currentML >= maxLength) {
                    maxLength = currentML;
                    maxLengthPoints = [points[i], points[j]];
                }
            }
        }
        return this.computed.maxLengthPoints = maxLengthPoints;
    }

    /**
        Calculates the maximum length between two pixels of the Roi.
     */
    get maxLength() {
        if (this.computed.maxLength) {
            return this.computed.maxLength;
        }
        var maxLength = Math.sqrt(Math.pow(this.maxLengthPoints[0][0] - this.maxLengthPoints[1][0], 2) + Math.pow(this.maxLengthPoints[0][1] - this.maxLengthPoints[1][1], 2));
        return this.computed.maxLength = maxLength;
    }

    get angle() {
        if (this.computed.angle) {
            return this.computed.angle;
        }
        var points = this.maxLengthPoints;
        var angle = -Math.atan2(points[0][1] - points[1][1], points[0][0] - points[1][0]) * 180 / Math.PI;

        return this.computed.angle = angle;
    }

    toJSON() {
        return {
            id: this.id,
            minX: this.minX,
            maxX: this.maxX,
            minY: this.minY,
            maxY: this.maxY,
            meanX: this.meanX,
            meanY: this.meanY,
            height: this.height,
            width: this.width,
            surface: this.surface
        };
    }
}

exports.default = Roi; // TODO we should follow the region in order to increase the speed

function getBorders(roi) {
    var roiMap = roi.map;
    var data = roiMap.data;
    var surroudingIDs = new Set(); // allows to get a unique list without indexOf
    var surroundingBorders = new Map();
    var visitedData = new Set();
    var dx = [+1, 0, -1, 0];
    var dy = [0, +1, 0, -1];

    for (var x = roi.minX; x <= roi.maxX; x++) {
        for (var y = roi.minY; y <= roi.maxY; y++) {
            var target = x + y * roiMap.width;
            if (data[target] === roi.id) {
                for (var dir = 0; dir < 4; dir++) {
                    var newX = x + dx[dir];
                    var newY = y + dy[dir];
                    if (newX >= 0 && newY >= 0 && newX < roiMap.width && newY < roiMap.height) {
                        var neighbour = newX + newY * roiMap.width;

                        if (data[neighbour] !== roi.id && !visitedData.has(neighbour)) {
                            visitedData.add(neighbour);
                            surroudingIDs.add(data[neighbour]);
                            var surroundingBorder = surroundingBorders.get(data[neighbour]);
                            if (!surroundingBorder) {
                                surroundingBorders.set(data[neighbour], 1);
                            } else {
                                surroundingBorders.set(data[neighbour], ++surroundingBorder);
                            }
                        }
                    }
                }
            }
        }
    }
    var ids = Array.from(surroudingIDs);
    var borderLengths = ids.map(function (id) {
        return surroundingBorders.get(id);
    });
    return {
        ids: ids,
        lengths: borderLengths
    };
}

function getBoxIDs(roi) {
    var surroundingIDs = new Set(); // allows to get a unique list without indexOf

    var roiMap = roi.map;
    var data = roiMap.data;

    // we check the first line and the last line
    var _arr = [0, roi.height - 1];
    for (var _i = 0; _i < _arr.length; _i++) {
        var y = _arr[_i];
        for (var _x = 0; _x < roi.width; _x++) {
            var target = (y + roi.minY) * roiMap.width + _x + roi.minX;
            if (_x - roi.minX > 0 && data[target] === roi.id && data[target - 1] !== roi.id) {
                var value = data[target - 1];
                surroundingIDs.add(value);
            }
            if (roiMap.width - _x - roi.minX > 1 && data[target] === roi.id && data[target + 1] !== roi.id) {
                var _value = data[target + 1];
                surroundingIDs.add(_value);
            }
        }
    }

    // we check the first column and the last column
    var _arr2 = [0, roi.width - 1];
    for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
        var x = _arr2[_i2];
        for (var _y = 0; _y < roi.height; _y++) {
            var _target = (_y + roi.minY) * roiMap.width + x + roi.minX;
            if (_y - roi.minY > 0 && data[_target] === roi.id && data[_target - roiMap.width] !== roi.id) {
                var _value2 = data[_target - roiMap.width];
                surroundingIDs.add(_value2);
            }
            if (roiMap.height - _y - roi.minY > 1 && data[_target] === roi.id && data[_target + roiMap.width] !== roi.id) {
                var _value3 = data[_target + roiMap.width];
                surroundingIDs.add(_value3);
            }
        }
    }

    return Array.from(surroundingIDs); // the selection takes the whole rectangle
}

function getBox(roi) {
    var total = 0;
    var roiMap = roi.map;
    var data = roiMap.data;

    var topBottom = [0];
    if (roi.height > 1) {
        topBottom[1] = roi.height - 1;
    }
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = topBottom[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var y = _step.value;

            for (var _x2 = 1; _x2 < roi.width - 1; _x2++) {
                var target = (y + roi.minY) * roiMap.width + _x2 + roi.minX;
                if (data[target] === roi.id) {
                    total++;
                }
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    var leftRight = [0];
    if (roi.width > 1) {
        leftRight[1] = roi.width - 1;
    }
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = leftRight[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var x = _step2.value;

            for (var _y2 = 0; _y2 < roi.height; _y2++) {
                var _target2 = (_y2 + roi.minY) * roiMap.width + x + roi.minX;
                if (data[_target2] === roi.id) {
                    total++;
                }
            }
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }

    return total;
}

function getBorder(roi) {
    var total = 0;
    var roiMap = roi.map;
    var data = roiMap.data;

    for (var x = 1; x < roi.width - 1; x++) {
        for (var y = 1; y < roi.height - 1; y++) {
            var target = (y + roi.minY) * roiMap.width + x + roi.minX;
            if (data[target] === roi.id) {
                // if a point around is not roi.id it is a border
                if (data[target - 1] !== roi.id || data[target + 1] !== roi.id || data[target - roiMap.width] !== roi.id || data[target + roiMap.width] !== roi.id) {
                    total++;
                }
            }
        }
    }
    return total + roi.box;
}

function getExternal(roi) {
    var total = 0;
    var roiMap = roi.map;
    var data = roiMap.data;

    for (var x = 1; x < roi.width - 1; x++) {
        for (var y = 1; y < roi.height - 1; y++) {
            var target = (y + roi.minY) * roiMap.width + x + roi.minX;
            if (data[target] === roi.id) {
                // if a point around is not roi.id it is a border
                if (roi.externalIDs.includes(data[target - 1]) || roi.externalIDs.includes(data[target + 1]) || roi.externalIDs.includes(data[target - roiMap.width]) || roi.externalIDs.includes(data[target + roiMap.width])) {
                    total++;
                }
            }
        }
    }
    return total + roi.box;
}

/*
We will calculate all the ids of the map that are "internal"
This will allow to extract the 'plain' image
 */
function getInternalIDs(roi) {
    var internal = [roi.id];
    var roiMap = roi.map;
    var data = roiMap.data;

    if (roi.height > 2) {
        for (var x = 0; x < roi.width; x++) {
            var target = roi.minY * roiMap.width + x + roi.minX;
            if (internal.includes(data[target])) {
                var id = data[target + roiMap.width];
                if (!internal.includes(id) && !roi.boxIDs.includes(id)) {
                    internal.push(id);
                }
            }
        }
    }

    var array = new Array(4);
    for (var _x3 = 1; _x3 < roi.width - 1; _x3++) {
        for (var y = 1; y < roi.height - 1; y++) {
            var _target3 = (y + roi.minY) * roiMap.width + _x3 + roi.minX;
            if (internal.includes(data[_target3])) {
                // we check if one of the neighbour is not yet in

                array[0] = data[_target3 - 1];
                array[1] = data[_target3 + 1];
                array[2] = data[_target3 - roiMap.width];
                array[3] = data[_target3 + roiMap.width];

                for (var i = 0; i < 4; i++) {
                    var _id = array[i];
                    if (!internal.includes(_id) && !roi.boxIDs.includes(_id)) {
                        internal.push(_id);
                    }
                }
            }
        }
    }

    return internal;
}