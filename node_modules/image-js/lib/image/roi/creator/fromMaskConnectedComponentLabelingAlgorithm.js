'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = fromKaskConnectedComponentLabelingAlgorithm;

var _mlDisjointSet = require('ml-disjoint-set');

var _mlDisjointSet2 = _interopRequireDefault(_mlDisjointSet);

var _RoiMap = require('../RoiMap');

var _RoiMap2 = _interopRequireDefault(_RoiMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
This algorithm is nice and is therefore kept here
However it seems to be slower than the get mask and
also provides only the positive ROI
We therefore don't expose it in the roiManager
 */

var direction4X = [-1, 0];
var direction4Y = [0, -1];
var neighbours4 = [null, null];

var direction8X = [-1, -1, 0, 1];
var direction8Y = [0, -1, -1, -1];
var neighbours8 = [null, null, null, null];

/*
Implementation of the connected-component labeling algorithm
 */
function fromKaskConnectedComponentLabelingAlgorithm(mask, options = {}) {
    var _options$allowCorners = options.allowCorners,
        allowCorners = _options$allowCorners === undefined ? false : _options$allowCorners;

    var neighbours = 4;
    if (allowCorners) {
        neighbours = 8;
    }

    var directionX = void 0;
    var directionY = void 0;
    var neighboursList = void 0;
    if (neighbours === 8) {
        directionX = direction8X;
        directionY = direction8Y;
        neighboursList = neighbours8;
    } else if (neighbours === 4) {
        directionX = direction4X;
        directionY = direction4Y;
        neighboursList = neighbours4;
    } else {
        throw new RangeError('unsupported neighbours count: ' + neighbours);
    }

    var size = mask.size;
    var width = mask.width;
    var height = mask.height;
    var labels = new Array(size);
    var data = new Int16Array(size);
    var linked = new _mlDisjointSet2.default();

    var currentLabel = 1;
    for (var j = 0; j < height; j++) {
        for (var i = 0; i < width; i++) {
            // true means out of background
            var index = i + j * width;
            if (mask.getBit(index)) {
                var smallestNeighbour = null;
                for (var k = 0; k < neighboursList.length; k++) {
                    var ii = i + directionX[k];
                    var jj = j + directionY[k];
                    if (ii >= 0 && jj >= 0 && ii < width && jj < height) {
                        var _index = ii + jj * width;
                        var neighbour = labels[_index];
                        if (!neighbour) {
                            neighboursList[k] = null;
                        } else {
                            neighboursList[k] = neighbour;
                            if (!smallestNeighbour || neighboursList[k].value < smallestNeighbour.value) {
                                smallestNeighbour = neighboursList[k];
                            }
                        }
                    }
                }
                if (!smallestNeighbour) {
                    labels[index] = linked.add(currentLabel++);
                } else {
                    labels[index] = smallestNeighbour;
                    for (var _k = 0; _k < neighboursList.length; _k++) {
                        if (neighboursList[_k] && neighboursList[_k] !== smallestNeighbour) {
                            linked.union(smallestNeighbour, neighboursList[_k]);
                        }
                    }
                }
            }
        }
    }

    for (var _j = 0; _j < height; _j++) {
        for (var _i = 0; _i < width; _i++) {
            var _index2 = _i + _j * width;
            if (mask.getBit(_index2)) {
                data[_index2] = linked.find(labels[_index2]).value;
            }
        }
    }

    return new _RoiMap2.default(mask, data);
}