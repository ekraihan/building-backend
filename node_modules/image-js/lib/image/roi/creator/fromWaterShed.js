'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = fromWaterShed;

var _RoiMap = require('../RoiMap');

var _RoiMap2 = _interopRequireDefault(_RoiMap);

var _jsPriorityQueue = require('js-priority-queue');

var _jsPriorityQueue2 = _interopRequireDefault(_jsPriorityQueue);

var _dxdy = require('./../../../util/dxdy.js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This method allows to create a ROIMap using the water shed algorithm. By default this algorithm
 * will fill the holes and therefore the lowest value of the image (black zones).
 * If no points are given, the function will look for all the minimal points.
 * If no mask is given the algorithm will completely fill the image.
 * Please take care about the value that has be in the mask ! In order to be coherent with the expected mask,
 * meaning that if it is a dark zone, the mask will be dark the normal behaviour to fill a zone
 * is that the mask pixel is clear (value of 0) !
 * However if you work in the 'invert' mode, the mask value has to be 'set' and the method will look for
 * maxima.
 * @memberof RoiManager
 * @instance
 * @param {object} [options={}]
 * @param {Array<Array<number>>} [options.points] - Array of points [[x1,y1], [x2,y2], ...].
 * @param {number} [options.fillMaxValue] - Limit of filling. By example, we can fill to a maximum value 32000 of a 16 bitDepth image.
 *          If invert this will corresponds to the minimal value
 * @param {Image} [options.image=this] - By default the waterShed will be applied on the current image. However waterShed can only be applied
 *                              on 1 component image. This allows to specify a grey scale image on which to apply waterShed..
 * @param {Image} [options.mask] - A binary image, the same size as the image. The algorithm will fill only if the current pixel in the binary mask is true.
 * @param {boolean} [options.invert=false] - By default we fill the minima
 * @return {RoiMap}
 */
function fromWaterShed(options = {}) {
    var points = options.points,
        mask = options.mask,
        image = options.image,
        _options$fillMaxValue = options.fillMaxValue,
        fillMaxValue = _options$fillMaxValue === undefined ? this.maxValue : _options$fillMaxValue,
        _options$invert = options.invert,
        invert = _options$invert === undefined ? false : _options$invert;

    var currentImage = image || this;
    currentImage.checkProcessable('fromWaterShed', {
        bitDepth: [8, 16],
        components: 1
    });

    /*
     We need to invert the logic because we are always using method to look for maxima and not minima and
     here water is expected to fill the minima first ...
    */

    invert = !invert;

    //WaterShed is done from points in the image. We can either specify those points in options,
    // or it is gonna take the minimum locals of the image by default.
    if (!points) {
        points = currentImage.getLocalMaxima({
            invert,
            mask
        });
    }

    var maskExpectedValue = invert ? 0 : 1;

    var data = new Int16Array(currentImage.size);
    var width = currentImage.width;
    var height = currentImage.height;
    var toProcess = new _jsPriorityQueue2.default({
        comparator: (a, b) => a[2] - b[2],
        strategy: _jsPriorityQueue2.default.BinaryHeapStrategy
    });
    for (var i = 0; i < points.length; i++) {
        var index = points[i][0] + points[i][1] * width;
        data[index] = i + 1;
        var intensity = currentImage.data[index];
        if (invert && intensity <= fillMaxValue || !invert && intensity >= fillMaxValue) {
            toProcess.queue([points[i][0], points[i][1], intensity]);
        }
    }

    //Then we iterate through each points
    while (toProcess.length > 0) {
        var currentPoint = toProcess.dequeue();
        var currentValueIndex = currentPoint[0] + currentPoint[1] * width;

        for (var dir = 0; dir < 4; dir++) {
            var newX = currentPoint[0] + _dxdy.dxs[dir];
            var newY = currentPoint[1] + _dxdy.dys[dir];
            if (newX >= 0 && newY >= 0 && newX < width && newY < height) {
                var currentNeighbourIndex = newX + newY * width;
                if (!mask || mask.getBit(currentNeighbourIndex) === maskExpectedValue) {
                    var _intensity = currentImage.data[currentNeighbourIndex];
                    if (invert && _intensity <= fillMaxValue || !invert && _intensity >= fillMaxValue) {
                        if (data[currentNeighbourIndex] === 0) {
                            data[currentNeighbourIndex] = data[currentValueIndex];
                            toProcess.queue([currentPoint[0] + _dxdy.dxs[dir], currentPoint[1] + _dxdy.dys[dir], _intensity]);
                        }
                    }
                }
            }
        }
    }

    return new _RoiMap2.default(currentImage, data);
}