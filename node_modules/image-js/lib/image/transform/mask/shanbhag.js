"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = shanbhag;
// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java
// Shanhbag A.G. (1994) "Utilization of Information Measure as a Means of
// Image Thresholding" Graphical Models and Image Processing, 56(5): 414-419
// Ported to ImageJ plugin by G.Landini from E Celebi's fourier_0.8 routines

function shanbhag(histogram, total) {
    var normHisto = new Array(histogram.length); // normalized histogram
    for (var ih = 0; ih < histogram.length; ih++) {
        normHisto[ih] = histogram[ih] / total;
    }

    var P1 = new Array(histogram.length); // cumulative normalized histogram
    var P2 = new Array(histogram.length);
    P1[0] = normHisto[0];
    P2[0] = 1.0 - P1[0];
    for (var _ih = 1; _ih < histogram.length; _ih++) {
        P1[_ih] = P1[_ih - 1] + normHisto[_ih];
        P2[_ih] = 1.0 - P1[_ih];
    }

    /* Determine the first non-zero bin */
    var firstBin = 0;
    for (var _ih2 = 0; _ih2 < histogram.length; _ih2++) {
        if (Math.abs(P1[_ih2]) >= Number.EPSILON) {
            firstBin = _ih2;
            break;
        }
    }

    /* Determine the last non-zero bin */
    var lastBin = histogram.length - 1;
    for (var _ih3 = histogram.length - 1; _ih3 >= firstBin; _ih3--) {
        if (Math.abs(P2[_ih3]) >= Number.EPSILON) {
            lastBin = _ih3;
            break;
        }
    }

    // Calculate the total entropy each gray-level
    // and find the threshold that maximizes it
    var threshold = -1;
    var minEnt = Number.MAX_VALUE; // min entropy

    var term = void 0;
    var totEnt = void 0; // total entropy
    var entBack = void 0; // entropy of the background pixels at a given threshold
    var entObj = void 0; // entropy of the object pixels at a given threshold
    for (var it = firstBin; it <= lastBin; it++) {
        /* Entropy of the background pixels */
        entBack = 0.0;
        term = 0.5 / P1[it];
        for (var _ih4 = 1; _ih4 <= it; _ih4++) {
            entBack -= normHisto[_ih4] * Math.log(1.0 - term * P1[_ih4 - 1]);
        }
        entBack *= term;

        /* Entropy of the object pixels */
        entObj = 0.0;
        term = 0.5 / P2[it];
        for (var _ih5 = it + 1; _ih5 < histogram.length; _ih5++) {
            entObj -= normHisto[_ih5] * Math.log(1.0 - term * P2[_ih5]);
        }
        entObj *= term;

        /* Total entropy */
        totEnt = Math.abs(entBack - entObj);

        if (totEnt < minEnt) {
            minEnt = totEnt;
            threshold = it;
        }
    }
    return threshold;
}