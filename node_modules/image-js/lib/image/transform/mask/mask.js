'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = mask;

var _Image = require('../../Image');

var _Image2 = _interopRequireDefault(_Image);

var _maskAlgorithms = require('./maskAlgorithms');

var _converter = require('../../../util/converter');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Creation of binary mask is based on the determination of a threshold
 * You may either choose among the provided algorithm or just specify a threshold value
 * @memberof Image
 * @instance
 * @param {object} [options]
 * @param {string} [options.algorithm='threshold']
 * @param {number} [options.threshold=0.5] - If the algorithm is 'threshold' specify here the value (0 to 1).
 * @param {boolean} [options.useAlpha=true] - Apply the alpha channel to determine the intensity of the pixel.
 * @param {boolean} [options.invert=false] - Invert the resulting image
 * @return {Image} - Binary image containing the mask
 */
function mask(options = {}) {
    var _options$algorithm = options.algorithm,
        algorithm = _options$algorithm === undefined ? 'threshold' : _options$algorithm,
        _options$threshold = options.threshold,
        threshold = _options$threshold === undefined ? 0.5 : _options$threshold,
        _options$useAlpha = options.useAlpha,
        useAlpha = _options$useAlpha === undefined ? true : _options$useAlpha,
        _options$invert = options.invert,
        invert = _options$invert === undefined ? false : _options$invert;


    this.checkProcessable('mask', {
        components: 1,
        bitDepth: [8, 16]
    });

    if (algorithm === 'threshold') {
        threshold = (0, _converter.getThreshold)(threshold, this.maxValue);
    } else {
        var method = _maskAlgorithms.methods[algorithm.toLowerCase()];
        if (method) {
            var histogram = this.getHistogram();
            threshold = method(histogram, this.size);
        } else {
            throw new Error('mask transform unknown algorithm: ' + algorithm);
        }
    }

    var newImage = new _Image2.default(this.width, this.height, {
        kind: 'BINARY',
        parent: this
    });

    var ptr = 0;
    if (this.alpha && useAlpha) {
        for (var i = 0; i < this.data.length; i += this.channels) {
            var value = this.data[i] + (this.maxValue - this.data[i]) * (this.maxValue - this.data[i + 1]) / this.maxValue;
            if (invert && value <= threshold || !invert && value >= threshold) {
                newImage.setBit(ptr);
            }
            ptr++;
        }
    } else {
        for (var _i = 0; _i < this.data.length; _i += this.channels) {
            if (invert && this.data[_i] <= threshold || !invert && this.data[_i] >= threshold) {
                newImage.setBit(ptr);
            }
            ptr++;
        }
    }

    return newImage;
}