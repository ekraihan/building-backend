"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = maxEntropy;
/*
 * see http://rsb.info.nih.gov/ij/developer/source/ij/process/AutoThresholder.java.html
 * The method is present in: Implements Kapur-Sahoo-Wong (Maximum Entropy) thresholding method:
 * Kapur, JN; Sahoo, PK & Wong, ACK (1985), "A New Method for Gray-Level Picture Thresholding Using the Entropy of the Histogram",
 * Graphical Models and Image Processing 29(3): 273-285
 * @param histogram - the histogram of the image
 *        total - the number of pixels in the image
 * @returns {number} - the threshold
 */

function maxEntropy(histogram, total) {
    var normHisto = new Array(histogram.length); // normalized histogram
    for (var ih = 0; ih < histogram.length; ih++) {
        normHisto[ih] = histogram[ih] / total;
    }

    var P1 = new Array(histogram.length); // cumulative normalized histogram
    var P2 = new Array(histogram.length);
    P1[0] = normHisto[0];
    P2[0] = 1.0 - P1[0];

    for (var _ih = 1; _ih < histogram.length; _ih++) {
        P1[_ih] = P1[_ih - 1] + normHisto[_ih];
        P2[_ih] = 1.0 - P1[_ih];
    }

    /* Determine the first non-zero bin */
    var firstBin = 0;
    for (var _ih2 = 0; _ih2 < histogram.length; _ih2++) {
        if (Math.abs(P1[_ih2]) >= Number.EPSILON) {
            firstBin = _ih2;
            break;
        }
    }

    /* Determine the last non-zero bin */
    var lastBin = histogram.length - 1;
    for (var _ih3 = histogram.length - 1; _ih3 >= firstBin; _ih3--) {
        if (Math.abs(P2[_ih3]) >= Number.EPSILON) {
            lastBin = _ih3;
            break;
        }
    }

    // Calculate the total entropy each gray-level
    // and find the threshold that maximizes it
    var threshold = -1;
    var totEnt = void 0; // total entropy
    var maxEnt = Number.MIN_VALUE; // max entropy
    var entBack = void 0; // entropy of the background pixels at a given threshold
    var entObj = void 0; // entropy of the object pixels at a given threshold

    for (var it = firstBin; it <= lastBin; it++) {
        /* Entropy of the background pixels */
        entBack = 0.0;
        for (var _ih4 = 0; _ih4 <= it; _ih4++) {
            if (histogram[_ih4] !== 0) {
                entBack -= normHisto[_ih4] / P1[it] * Math.log(normHisto[_ih4] / P1[it]);
            }
        }

        /* Entropy of the object pixels */
        entObj = 0.0;
        for (var _ih5 = it + 1; _ih5 < histogram.length; _ih5++) {
            if (histogram[_ih5] !== 0) {
                entObj -= normHisto[_ih5] / P2[it] * Math.log(normHisto[_ih5] / P2[it]);
            }
        }

        /* Total entropy */
        totEnt = entBack + entObj;

        if (maxEnt < totEnt) {
            maxEnt = totEnt;
            threshold = it;
        }
    }
    return threshold;
}