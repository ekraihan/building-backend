'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = renyiEntropy;

var _numSort = require('num-sort');

function renyiEntropy(histogram, total) {
    var optThreshold = void 0; //Optimal threshold
    var firstBin = void 0; //First non-zero bin
    var lastBin = void 0; //last non-zero bin

    var normHisto = new Array(histogram.length); //normalized histogram
    var P1 = new Array(histogram.length); //acumulative normalized histogram
    var P2 = new Array(histogram.length); //acumulative normalized histogram

    //Entropy Variables
    var threshold1 = 0;
    var threshold2 = 0;
    var threshold3 = 0;
    var maxEnt1 = 0.0;
    var maxEnt2 = 0.0;
    var maxEnt3 = 0.0;
    var alpha2 = 0.5;
    var term2 = 1.0 / (1.0 - alpha2);
    var alpha3 = 2.0;
    var term3 = 1.0 / (1.0 - alpha3);

    for (var ih = 0; ih < histogram.length; ih++) {
        normHisto[ih] = histogram[ih] / total;
    }

    P1[0] = normHisto[0];
    P2[0] = 1.0 - P1[0];
    for (var _ih = 1; _ih < histogram.length; _ih++) {
        P1[_ih] = P1[_ih - 1] + normHisto[_ih];
        P2[_ih] = 1.0 - P1[_ih];
    }

    /* Determine the first non-zero bin */
    firstBin = 0;
    for (var _ih2 = 0; _ih2 < histogram.length; _ih2++) {
        if (Math.abs(P1[_ih2]) >= Number.EPSILON) {
            firstBin = _ih2;
            break;
        }
    }

    /* Determine the last non-zero bin */
    lastBin = histogram.length - 1;
    for (var _ih3 = histogram.length - 1; _ih3 >= firstBin; _ih3--) {
        if (Math.abs(P2[_ih3]) >= Number.EPSILON) {
            lastBin = _ih3;
            break;
        }
    }

    /* Maximum Entropy Thresholding - BEGIN */
    /* ALPHA = 1.0 */
    /* Calculate the total entropy each gray-level
     and find the threshold that maximizes it
     */
    for (var it = firstBin; it <= lastBin; it++) {
        /* Entropy of the background pixels */
        var entBack1 = 0.0;
        var entBack2 = 0.0;
        var entBack3 = 0.0;
        for (var _ih4 = 0; _ih4 <= it; _ih4++) {
            if (histogram[_ih4] !== 0) {
                entBack1 -= normHisto[_ih4] / P1[it] * Math.log(normHisto[_ih4] / P1[it]);
            }
            entBack2 += Math.sqrt(normHisto[_ih4] / P1[it]);
            entBack3 += normHisto[_ih4] * normHisto[_ih4] / (P1[it] * P1[it]);
        }

        /* Entropy of the object pixels */
        var entObj1 = 0.0;
        var entObj2 = 0.0;
        var entObj3 = 0.0;
        for (var _ih5 = it + 1; _ih5 < histogram.length; _ih5++) {
            if (histogram[_ih5] !== 0) {
                entObj1 -= normHisto[_ih5] / P2[it] * Math.log(normHisto[_ih5] / P2[it]);
            }
            entObj2 += Math.sqrt(normHisto[_ih5] / P2[it]);
            entObj3 += normHisto[_ih5] * normHisto[_ih5] / (P2[it] * P2[it]);
        }

        /* Total entropy */
        var totEnt1 = entBack1 + entObj1;
        var totEnt2 = term2 * (entBack2 * entObj2 > 0.0 ? Math.log(entBack2 * entObj2) : 0.0);
        var totEnt3 = term3 * (entBack3 * entObj3 > 0.0 ? Math.log(entBack3 * entObj3) : 0.0);

        if (totEnt1 > maxEnt1) {
            maxEnt1 = totEnt1;
            threshold1 = it;
        }

        if (totEnt2 > maxEnt2) {
            maxEnt2 = totEnt2;
            threshold2 = it;
        }

        if (totEnt3 > maxEnt3) {
            maxEnt3 = totEnt3;
            threshold3 = it;
        }
    }
    /* End Maximum Entropy Thresholding */

    var tStars = [threshold1, threshold2, threshold3];
    tStars.sort(_numSort.asc);

    var betas = void 0;

    /* Adjust beta values */
    if (Math.abs(tStars[0] - tStars[1]) <= 5) {
        if (Math.abs(tStars[1] - tStars[2]) <= 5) {
            betas = [1, 2, 1];
        } else {
            betas = [0, 1, 3];
        }
    } else {
        if (Math.abs(tStars[1] - tStars[2]) <= 5) {
            betas = [3, 1, 0];
        } else {
            betas = [1, 2, 1];
        }
    }

    /* Determine the optimal threshold value */
    var omega = P1[tStars[2]] - P1[tStars[0]];
    optThreshold = Math.round(tStars[0] * (P1[tStars[0]] + 0.25 * omega * betas[0]) + 0.25 * tStars[1] * omega * betas[1] + tStars[2] * (P2[tStars[2]] + 0.25 * omega * betas[2]));

    return optThreshold;
} // see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java
// Kapur J.N., Sahoo P.K., and Wong A.K.C. (1985) "A New Method for
// Gray-Level Picture Thresholding Using the Entropy of the Histogram"
// Graphical Models and Image Processing, 29(3): 273-285
// M. Emre Celebi
// 06.15.2007
// Ported to ImageJ plugin by G.Landini from E Celebi's fourier_0.8 routines