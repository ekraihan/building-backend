'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = scale;

var _Image = require('../../Image');

var _Image2 = _interopRequireDefault(_Image);

var _nearestNeighbor = require('./nearestNeighbor');

var _nearestNeighbor2 = _interopRequireDefault(_nearestNeighbor);

var _converter = require('../../../util/converter');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Rescale an image
 * @memberof Image
 * @instance
 * @param {object} [options]
 * @param {number} [options.width=this.width] - new width
 * @param {number} [options.height=this.height] - new height
 * @param {number} [options.factor=1] - scaling factor (applied to the new width and height values)
 * @param {string} [options.algorithm='nearestNeighbor']
 * @param {boolean} [options.preserveAspectRatio=true] - preserve width/height ratio if only one of them is defined
 * @return {Image}
 */
function scale(options = {}) {
    var _options$factor = options.factor,
        factor = _options$factor === undefined ? 1 : _options$factor,
        _options$algorithm = options.algorithm,
        algorithm = _options$algorithm === undefined ? 'nearestNeighbor' : _options$algorithm,
        _options$preserveAspe = options.preserveAspectRatio,
        preserveAspectRatio = _options$preserveAspe === undefined ? true : _options$preserveAspe;


    var width = options.width;
    var height = options.height;

    if (!width) {
        if (height && preserveAspectRatio) {
            width = Math.round(height * (this.width / this.height));
        } else {
            width = this.width;
        }
    }
    if (!height) {
        if (preserveAspectRatio) {
            height = Math.round(width * (this.height / this.width));
        } else {
            height = this.height;
        }
    }

    var _factorDimensions = (0, _converter.factorDimensions)(factor, width, height);

    width = _factorDimensions.width;
    height = _factorDimensions.height;


    if (width === this.width && height === this.height) {
        var _newImage = this.clone();
        _newImage.position = [0, 0];
        return _newImage;
    }

    var shiftX = Math.round((this.width - width) / 2);
    var shiftY = Math.round((this.height - height) / 2);
    var newImage = _Image2.default.createFrom(this, { width, height, position: [shiftX, shiftY] });

    switch (algorithm.toLowerCase()) {
        case 'nearestneighbor':
        case 'nearestneighbour':
            _nearestNeighbor2.default.call(this, newImage, width, height);
            break;
        default:
            throw new Error('Unsupported scale algorithm: ' + algorithm);
    }

    return newImage;
}