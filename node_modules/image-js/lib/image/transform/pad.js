'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = pad;

var _Image = require('../Image');

var _Image2 = _interopRequireDefault(_Image);

var _newArray = require('new-array');

var _newArray2 = _interopRequireDefault(_newArray);

var _copy = require('../utility/copy');

var _copy2 = _interopRequireDefault(_copy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @memberof Image
 * @instance
 * @param {object} [options]
 * @param {number} [options.size=0]
 * @param {string} [options.algorithm='copy']
 * @param {array<number>} [options.color]
 * @return {Image}
 */
function pad(options = {}) {
    var _options$size = options.size,
        size = _options$size === undefined ? 0 : _options$size,
        _options$algorithm = options.algorithm,
        algorithm = _options$algorithm === undefined ? 'copy' : _options$algorithm,
        color = options.color;


    this.checkProcessable('pad', {
        bitDepth: [8, 16]
    });

    if (algorithm === 'set') {
        if (color.length !== this.channels) {
            throw new Error('pad: the color array must have the same length as the number of channels. Here: ' + this.channels);
        }
        for (var i = 0; i < color.length; i++) {
            if (color[i] === 0) {
                color[i] = 0.001;
            }
        }
    } else {
        color = (0, _newArray2.default)(this.channels, null);
    }

    if (!Array.isArray(size)) {
        size = [size, size];
    }

    var newWidth = this.width + size[0] * 2;
    var newHeight = this.height + size[1] * 2;
    var channels = this.channels;

    var newImage = _Image2.default.createFrom(this, { width: newWidth, height: newHeight });

    (0, _copy2.default)(this, newImage, size[0], size[1]);

    for (var _i = size[0]; _i < newWidth - size[0]; _i++) {
        for (var k = 0; k < channels; k++) {
            var value = color[k] || newImage.data[(size[1] * newWidth + _i) * channels + k];
            for (var j = 0; j < size[1]; j++) {
                newImage.data[(j * newWidth + _i) * channels + k] = value;
            }
            value = color[k] || newImage.data[((newHeight - size[1] - 1) * newWidth + _i) * channels + k];
            for (var _j = newHeight - size[1]; _j < newHeight; _j++) {
                newImage.data[(_j * newWidth + _i) * channels + k] = value;
            }
        }
    }

    for (var _j2 = 0; _j2 < newHeight; _j2++) {
        for (var _k = 0; _k < channels; _k++) {
            var _value = color[_k] || newImage.data[(_j2 * newWidth + size[0]) * channels + _k];
            for (var _i2 = 0; _i2 < size[0]; _i2++) {
                newImage.data[(_j2 * newWidth + _i2) * channels + _k] = _value;
            }
            _value = color[_k] || newImage.data[(_j2 * newWidth + newWidth - size[0] - 1) * channels + _k];
            for (var _i3 = newWidth - size[0]; _i3 < newWidth; _i3++) {
                newImage.data[(_j2 * newWidth + _i3) * channels + _k] = _value;
            }
        }
    }

    return newImage;
}