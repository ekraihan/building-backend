'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = matchAndCrop;

var _Stack = require('../Stack');

var _Stack2 = _interopRequireDefault(_Stack);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// TODO this code seems buggy if it is not 0,0
/**
 * We will try to move a set of images in order to get only the best common part of them.
 * In a stack, we compare 2 consecutive images or directly to a parent.
 * Ignoring border may be dangerous ! If there is a shape on the side of the image there will be a
 * continuous shift if you ignore border. By default it is better to leave it to 0,0
 * Now if the background is not black there will also be no way to shift ...
 * It may therefore be much better to make a background correction before trying to match and crop.
 * @memberof Stack
 * @instance
 * @param {object} [options]
 * @param {string} [options.algorithm='matchToPrevious'] - matchToPrevious or matchToFirst
 * @param {number[]} [options.ignoreBorder=[0, 0]]
 * @return {Stack}
 */
function matchAndCrop(options = {}) {
    var _options$algorithm = options.algorithm,
        algorithm = _options$algorithm === undefined ? 'matchToPrevious' : _options$algorithm,
        _options$ignoreBorder = options.ignoreBorder,
        ignoreBorder = _options$ignoreBorder === undefined ? [0, 0] : _options$ignoreBorder;


    this.checkProcessable('matchAndCrop', {
        bitDepth: [8, 16]
    });

    var matchToPrevious = algorithm === 'matchToPrevious';

    var parent = this[0];
    var results = [];
    results[0] = {
        position: [0, 0],
        image: this[0]
    };

    var relativePosition = [0, 0];

    // we calculate the best relative position to the parent image
    for (var i = 1; i < this.length; i++) {

        var position = parent.getBestMatch(this[i], { border: ignoreBorder });

        results[i] = {
            position: [position[0] + relativePosition[0], position[1] + relativePosition[1]],
            image: this[i]
        };
        if (matchToPrevious) {
            relativePosition[0] += position[0];
            relativePosition[1] += position[1];
            parent = this[i];
        }
    }
    // now we can calculate the cropping that we need to do

    var leftShift = 0;
    var rightShift = 0;
    var topShift = 0;
    var bottomShift = 0;

    for (var _i = 0; _i < results.length; _i++) {
        var result = results[_i];
        if (result.position[0] > leftShift) {
            leftShift = result.position[0];
        }
        if (result.position[0] < rightShift) {
            rightShift = result.position[0];
        }
        if (result.position[1] > topShift) {
            topShift = result.position[1];
        }
        if (result.position[1] < bottomShift) {
            bottomShift = result.position[1];
        }
    }
    rightShift = 0 - rightShift;
    bottomShift = 0 - bottomShift;

    for (var _i2 = 0; _i2 < results.length; _i2++) {
        var _result = results[_i2];

        _result.crop = _result.image.crop({
            x: leftShift - _result.position[0],
            y: topShift - _result.position[1],
            width: parent.width - rightShift - leftShift,
            height: parent.height - bottomShift - topShift
        });
    }

    // finally we crop and create a new array of images
    var newImages = [];
    for (var _i3 = 0; _i3 < results.length; _i3++) {
        newImages[_i3] = results[_i3].crop;
    }

    return new _Stack2.default(newImages);
}