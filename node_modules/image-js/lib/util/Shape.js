'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _mlMatrix = require('ml-matrix');

var _mlMatrix2 = _interopRequireDefault(_mlMatrix);

var _Image = require('../image/Image');

var _Image2 = _interopRequireDefault(_Image);

var _kindNames = require('../image/kindNames');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var cross = [[0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [1, 1, 1, 1, 1], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0]];

var smallCross = [[0, 1, 0], [1, 1, 1], [0, 1, 0]];

/**
 * Class representing a shape
 * @class Shape
 * @param {object} [options]
 * @param {string} [options.kind='cross'] - Predefined matrix shape, 'cross' or 'smallCross'
 * @param {string} [options.shape] - Value may be 'square', 'rectangle', 'circle', 'ellipse' or 'triangle'
 *                                  The size of the shape will be determined by the size, width and height.
 *                                  A Shape is by default filled.
 * @param {number} [options.size]
 * @param {number} [options.width=options.size] - width of the shape. Must be odd.
 * @param {number} [options.height=options.size] - width of the shape. Must be odd.
 * @param {boolean} [options.filled=true] - If false only the border ot the shape is taken into account.
 */
class Shape {
    constructor(options = {}) {
        var _options$kind = options.kind,
            kind = _options$kind === undefined ? 'cross' : _options$kind,
            shape = options.shape,
            size = options.size,
            width = options.width,
            height = options.height,
            _options$filled = options.filled,
            filled = _options$filled === undefined ? true : _options$filled;

        if (size) {
            width = size;
            height = size;
        }
        if (width && 1 !== 1 || height && 1 !== 1) {
            throw Error('Shape: The width and height has to be odd numbers.');
        }
        if (shape) {
            switch (shape.toLowerCase()) {
                case 'square':
                case 'rectangle':
                    this.matrix = rectangle(width, height, { filled });
                    break;
                case 'circle':
                case 'ellipse':
                    this.matrix = ellipse(width, height, { filled });
                    break;
                case 'triangle':
                    this.matrix = triangle(width, height, { filled });
                    break;
                default:
                    throw new Error(`Shape: unexpected shape: ${shape}`);
            }
        } else if (kind) {
            switch (kind.toLowerCase()) {
                case 'cross':
                    this.matrix = cross;
                    break;
                case 'smallcross':
                    this.matrix = smallCross;
                    break;
                default:
                    throw new Error(`Shape: unexpected kind: ${kind}`);
            }
        } else {
            throw new Error('Shape: expected a kind or a shape option');
        }
        this.height = this.matrix.length;
        this.width = this.matrix[0].length;
        this.halfHeight = this.height / 2 >> 0;
        this.halfWidth = this.width / 2 >> 0;
    }

    /**
     * Returns an array of [x,y] points
     * @return {Array<Array<number>>} - Array of [x,y] points
     */
    getPoints() {
        var matrix = this.matrix;
        var points = [];
        for (var y = 0; y < matrix.length; y++) {
            for (var x = 0; x < matrix[0].length; x++) {
                if (matrix[y][x]) {
                    points.push([x - this.halfWidth, y - this.halfHeight]);
                }
            }
        }
        return points;
    }

    /**
     * Returns a Mask (1 bit Image) corresponding to this shape.
     * @return {Image}
     */
    getMask() {
        var img = new _Image2.default(this.width, this.height, {
            kind: _kindNames.BINARY
        });
        for (var y = 0; y < this.matrix.length; y++) {
            for (var x = 0; x < this.matrix[0].length; x++) {
                if (this.matrix[y][x]) {
                    img.setBitXY(x, y);
                }
            }
        }
        return img;
    }
}

exports.default = Shape;
function rectangle(width, height, options) {
    var matrix = _mlMatrix2.default.zeros(height, width);
    if (options.filled) {
        for (var y = 0; y < height; y++) {
            for (var x = 0; x < width; x++) {
                matrix.set(y, x, 1);
            }
        }
    } else {
        var _arr = [0, height - 1];

        for (var _i = 0; _i < _arr.length; _i++) {
            var _y = _arr[_i];
            for (var _x2 = 0; _x2 < width; _x2++) {
                matrix.set(_y, _x2, 1);
            }
        }
        for (var _y2 = 0; _y2 < height; _y2++) {
            var _arr2 = [0, width - 1];

            for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
                var _x = _arr2[_i2];
                matrix.set(_y2, _x, 1);
            }
        }
    }

    return matrix;
}

function ellipse(width, height, options) {
    var matrix = _mlMatrix2.default.zeros(height, width, options);
    var yEven = 1 - height % 2;
    var xEven = 1 - width % 2;
    var a = Math.floor((width - 1) / 2); // horizontal ellipse axe
    var b = Math.floor((height - 1) / 2); // vertical ellipse axe
    var a2 = a * a;
    var b2 = b * b;
    if (options.filled) {
        for (var y = 0; y <= b; y++) {
            var shift = Math.floor(Math.sqrt(a2 - a2 * y * y / b2));
            for (var x = a - shift; x <= a; x++) {
                matrix.set(b - y, x, 1);
                matrix.set(b + y + yEven, x, 1);
                matrix.set(b - y, width - x - 1, 1);
                matrix.set(b + y + yEven, width - x - 1, 1);
            }
        }
    } else {
        for (var _y3 = 0; _y3 <= b; _y3++) {
            var _shift = Math.floor(Math.sqrt(a2 - a2 * _y3 * _y3 / b2));
            var _x3 = a - _shift;
            matrix.set(b - _y3, _x3, 1);
            matrix.set(b + _y3 + yEven, _x3, 1);
            matrix.set(b - _y3, width - _x3 - 1, 1);
            matrix.set(b + _y3 + yEven, width - _x3 - 1, 1);
        }

        for (var _x4 = 0; _x4 <= a; _x4++) {
            var _shift2 = Math.floor(Math.sqrt(b2 - b2 * _x4 * _x4 / a2));
            var _y4 = b - _shift2;
            matrix.set(_y4, a - _x4, 1);
            matrix.set(_y4, a + _x4 + xEven, 1);
            matrix.set(height - _y4 - 1, a - _x4, 1);
            matrix.set(height - _y4 - 1, a + _x4 + xEven, 1);
        }
    }
    return matrix;
}

function triangle(width, height, options) {
    if (!options.filled) {
        throw new Error('Non filled triangle is not implemented');
    }
    var matrix = _mlMatrix2.default.zeros(height, width, options);
    for (var y = 0; y < height; y++) {
        var shift = Math.floor((1 - y / height) * width / 2);
        for (var x = shift; x < width - shift; x++) {
            matrix.set(y, x, 1);
        }
    }
    return matrix;
}